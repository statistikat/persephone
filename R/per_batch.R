#' R6 Class for hierarchical time series
#'
#' @description Combine mutliple objects of persephone objects into a new
#'   persephone object. On the resulting objects seasonal adjustment can
#'   be performed to all elements at once
#' @examples
#' \dontrun{
#' obj_x13 <- per_x13(AirPassengers, "RSA3")
#'
#' bt <- per_batch(a = obj_x13, b = obj_x13, method = "x13")
#' bt$run()
#'
#' bt$adjusted
#'
#' bt$updateParams(easter.enabled = FALSE)
#'
#' bt$updateParams(component = "a", usrdef.outliersEnabled = TRUE,
#'                      usrdef.outliersType = c("AO","LS","LS"),
#'                      usrdef.outliersDate=c("1950-01-01","1955-04-01","1959-10-01"))
#' }
#'
#' @export
multipleTimeSeries <- R6::R6Class(
  "multipleTimeSeries",
  inherit = persephone,
  public = list(
    #' @description create a new multiple time series object
    #' @param ... one or more objects which are either of class persephone or
    #'   can be coerced to persephone objects with as_persephone. If more than
    #'   one element is supplied, the underlying time series must have the same
    #'   time instances. All elements supplied in ... must be named.
    #' @param method specifies the method to be used for the direct adjustment
    #'   of the aggregate series. tramoseats or x13
    #' @param userdefined passed as the userdefined argument to tramoseats() or
    #'   x13()
    #' @param spec a model specification returned by x13_spec() or
    #'   tramoseats_spec()
    #' @param list a list of persephone objects as alternative input to `...`.
    #'   This argument can also handle mts objects
    initialize = function(..., method = c("tramoseats", "x13"),
                          userdefined = NULL, spec = NULL, list = NULL
                          ) {
      private$method <- match.arg(method)
      if (!is.null(list)) {
        components <- list
        if (is.null(names(components))) {
          names(components) <- paste0("ts", seq_along(components))
        }
        if (length(list(...)) > 0) {
          warning("If the list argument is specified, additional arguments ",
                  " as ... will be ignored.")
        }
      } else {
        components <- list(...)
      }
      print(components)
      components <- lapply(components, as.persephone)
      componentsHts <- sapply(
        components,
        function(x) "multipleTimeSeries" %in% class(x))
      private$check_classes(components)
      names(components) <- private$coerce_component_names(components)
      private$tsp_internal <- private$check_time_instances(components)
      self$components <- components
      super$set_options(userdefined = userdefined, spec = spec)
    },
    #' @description run the model
    #' @param verbose if `FALSE` (the default), the results of the run will
    #'   be returned invisibly
    #' @examples per_x13(AirPassengers)$run()
    run = function(verbose = FALSE) {
      invisible(lapply(self$components, function(component) {
        component$run(verbose = verbose)
      }))

    },
    #' @field components the series of the multiple time series
    components = NULL,
    #' @description print mutliple timeseries to screen
    print = function() {
      tbl <- private$print_table()
      if (all(!tbl$run))
        tbl <- tbl[, 1:3]
      print(tbl, right = FALSE, row.names = FALSE)
    },
    #' @description sets options for all entries of the dependency tree
    #'   recursively (if recursive = TRUE). See
    #'   vignette("persephone-hierarchical") for more details.
    #' @param userdefined additional outputs to generate while running. See
    #'   [x13()] and [tramoseats()].
    #' @param spec specifications generated by `x13_spec()` or
    #'   `tramoseats_spec()`
    #' @param component which component to modify.
    set_options = function(userdefined = NA, spec = NA,
                           component = "") {
      if (component != "") {
        root <- self$get_component(component)
        return(root$set_options(userdefined, spec))
      }
      super$set_options(userdefined, spec)
      invisible(NULL)
    },
    #' @description iterate over all components
    #' @details this functin is similar to `lapply()` in the sense that it
    #'   can be used to apply a function to several persephone objects
    #'   simultaniusely
    #' @param fun a function that takes a persephone object as a parameter
    #' @param as_table if true, the return value of this method will be coerced
    #'   to a data.frame
    #' @param component the id of the component
    #' @param unnest if `as_table = FALSE`, converts the return value from a
    #'   nested list into a flat list
    iterate = function(fun, as_table = FALSE, component = "", unnest = FALSE) {
      if (component != "") {
        root <- self$get_component(component)
        return(root$iterate(fun, as_table))
      }
      comp <- lapply(
        self$components,
        function(component) {
          component$iterate(fun)
        }
      )

      private$convert_list(comp, as_table, unnest)
    },
#' @description change all or some parameters of components
#' @details this functions provides the possibility to update
#' parameters of one or more persephone single objects
#'
#' @param component character vector with names of the components
#' for which the parameters should be changed. If NULL (default) the
#' parameters of all components will be changed
#' @param ... named arguments to be changed
updateParams = function(component = NULL, ...) {
  if(is.null(component)){
    lapply(self$components,function(x)x$updateParams(...))
  }else{
    lapply(self$components[component],function(x)x$updateParams(...))
  }
},

    #' @description extract a component series
    #' @param component_id the id of a component
    get_component = function(component_id) {
      if(!component_id%in%names(self$components)){
        stop(component_id," not found.")
      }
      self$components[[component_id]]
    },
    #' @description Generate a table for the eurostat quality report
    #' @param component (optional) a sub-component to create the report for
    #' @param ... additional arguments for the generate qr table function
    generate_qr_table = function(component = "",...) {
      if(component!=""){
        self$get_component(component)$generate_qr_table(...)
      }else{
        self$iterate(generateQrList, as_table = TRUE)
      }
    }
  ),
  active = list(
    #' @field adjusted results from the seasonal adjustment
    adjusted = function() {
      lapply(self$components,function(x)x$adjusted)
    },
    #' @field params of all components
    params = function() {
      lapply(self$components,function(x)x$params)
    },
    #' @field forecasts get forecasts
    forecasts = function() {
      lapply(self$components,function(x)x$forecasts)
    }
  ),
  private = list(
    check_classes = function(components) {
      lapply(components, function(component) {
        stopifnot(is.persephone(component))
      })
    },
    print_table = function() {
      self$iterate(printDiagnostics, as_table = TRUE)
    },
    check_time_instances = function(components) {
      tsps <- lapply(components, function(component) {
        component$tsp
      })
      if (length(unique(tsps)) != 1)
        stop("All components need to have the same time instances")
      tsps[[1]]
    },
    coerce_component_names = function(components) {
      lapply(seq_along(components), function(i) {
        parname <- names(components)[i]
        if (!is.null(parname) && parname != "")
          return(parname)
        else
          stop("all components in 'multipleTimeSeries' must be named")
      })
    },
    method = NULL,
    spec = NULL
  )
)

#' Define a multiple time series
#'
#' Combine mutliple objects of persephone objects into a new persephone batch object.
#' On the resulting objects, you can perform seasonal adjustment.
#'
#' @param ... ne or more objects which are either of class persephone or can be
#'   coerced to persephone objects with as_persephone. If more than one element
#'   is supplied, the underlying time series must have the same time instances.
#'   All elements supplied in ... must be named.
#' @param method specifies the method to be used for the adjustment of
#'   the aggregate series. tramoseats or x13
#' @param userdefined passed as the userdefined argument to tramoseats() or x13()
#' @param spec  a model specification returned by x13_spec() or
#'   tramoseats_spec()
#' @param list a list of persephone objects as alternative input to `...`. This
#'   argument can also handle mts objects
#' @export
per_batch <- function(..., method = c("tramoseats", "x13"),
                    userdefined = NULL, spec = NULL, list = NULL) {
  multipleTimeSeries$new(..., method = method, userdefined = userdefined,
                             spec = spec, list = list)
}
