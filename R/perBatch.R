#' R6 Class for hierarchical time series
#'
#' @description Combine mutliple objects of persephone objects into a new
#'   persephone object. On the resulting objects seasonal adjustment can
#'   be performed to all elements at once
#' @examples
#' \dontrun{
#' objX13 <- perX13(AirPassengers, "RSA3")
#'
#' bt <- perBatch(a = objX13, b = objX13)
#' bt$run()
#'
#' bt$adjusted
#'
#' bt$updateParams(easter.enabled = FALSE)
#'
#' bt$updateParams(component = "a", usrdef.outliersEnabled = TRUE,
#'                      usrdef.outliersType = c("AO","LS","LS"),
#'                      usrdef.outliersDate=c("1950-01-01","1955-04-01","1959-10-01"))
#'
#' bt$fixModel()
#' }
#'
#' @export
multipleTimeSeries <- R6::R6Class(
  "multipleTimeSeries",
  inherit = persephone,
  public = list(
    #' @description create a new multiple time series object
    #' @param ... one or more objects which are either of class persephone or
    #'   can be coerced to persephone objects with asPersephone. If more than
    #'   one element is supplied, the underlying time series must have the same
    #'   time instances. All elements supplied in ... must be named.
    #' @param list a list of persephone objects as alternative input to `...`.
    #'   This argument can also handle mts objects
    initialize = function(..., list = NULL
                          ) {
      if (!is.null(list)) {
        components <- list
        if (is.null(names(components))) {
          names(components) <- paste0("ts", seq_along(components))
        }
        if (length(list(...)) > 0) {
          warning("If the list argument is specified, additional arguments ",
                  " as ... will be ignored.")
        }
      } else {
        components <- list(...)
      }
      components <- lapply(components, as.persephone)
      componentsHts <- sapply(
        components,
        function(x) "multipleTimeSeries" %in% class(x))
      private$check_classes(components)
      names(components) <- private$coerce_component_names(components)
      private$tsp_internal <- private$check_time_instances(components)
      self$components <- components
    },
    #' @description run the model
    #' @param verbose if `FALSE` (the default), the results of the run will
    #'   be returned invisibly
    #' @examples perX13(AirPassengers)$run()
    run = function(verbose = FALSE) {
      invisible(lapply(self$components, function(component) {
        component$run(verbose = verbose)
      }))

    },
    #' @field components the series of the multiple time series
    components = NULL,
    #' @description print mutliple timeseries to screen
    print = function() {
      tbl <- private$printTable()
      if (all(!tbl$run))
        tbl <- tbl[, 1:3]
      print(tbl, right = FALSE, row.names = FALSE)
    },
    #' @description sets options for all entries of the dependency tree
    #'   recursively (if recursive = TRUE). See
    #'   vignette("persephone-hierarchical") for more details.
    #' @param userdefined additional outputs to generate while running. See
    #'   [x13()] and [tramoseats()].
    #' @param spec specifications generated by `x13_spec()` or
    #'   `tramoseats_spec()`
    #' @param component which component to modify.
    setOptions = function(userdefined = NA, spec = NA, component = "") {
      if (component != "") {
        root <- self$getComponent(component)
        return(root$setOptions(userdefined, spec))
      }else{
        stop("Batch objects dont have a spec or userdefined argument.")
      }
      invisible(NULL)
    },
    #' @description iterate over all components
    #' @details this functin is similar to `lapply()` in the sense that it
    #'   can be used to apply a function to several persephone objects
    #'   simultaniusely
    #' @param fun a function that takes a persephone object as a parameter
    #' @param asTable if true, the return value of this method will be coerced
    #'   to a data.frame
    #' @param component the id of the component
    #' @param unnest if `asTable = FALSE`, converts the return value from a
    #'   nested list into a flat list
    iterate = function(fun, asTable = FALSE, component = "", unnest = FALSE) {
      if (component != "") {
        root <- self$getComponent(component)
        return(root$iterate(fun, asTable))
      }
      comp <- lapply(
        self$components,
        function(component) {
          component$iterate(fun)
        }
      )

      private$convert_list(comp, asTable, unnest)
    },
#' @description change all or some parameters of components
#' @details this functions provides the possibility to update
#' parameters of one or more persephone single objects
#'
#' @param component character vector with names of the components
#' for which the parameters should be changed. If NULL (default) the
#' parameters of all components will be changed
#' @param ... named arguments to be changed
updateParams = function(component = NULL, ...) {
  if(is.null(component)){
    invisible(lapply(self$components,function(x)x$updateParams(...)))
  }else{
    invisible(lapply(self$components[component],function(x)x$updateParams(...)))
  }
},

    #' @description extract a component series
    #' @param componentId the id of a component
    getComponent = function(componentId) {
      if(!componentId%in%names(self$components)){
        stop(componentId," not found.")
      }
      self$components[[componentId]]
    },
    #' @description Generate a table for the eurostat quality report
    #' @param component (optional) a sub-component to create the report for
    #' @param ... additional arguments for the generate qr table function
    generateQrTable = function(component = "",...) {
      if(component!=""){
        self$getComponent(component)$generateQrTable(...)
      }else{
        self$iterate(generateQrList, asTable = TRUE)
      }
    },
#' @description fix the arima model(s)
#' @param component character vector with names of the components
#' for which the parameters should be changed. If NULL (default) the
#' parameters of all components will be changed
#' @param verbose if TRUE the changed parameters will be reported
fixModel = function(component = NULL, verbose = FALSE) {
  if(!is.null(component)){
    lapply(self$components[component],function(x)x$fixModel(verbose = verbose))
  }else{
    lapply(self$components,function(x)x$fixModel(verbose = verbose))
  }
  return(invisible(NULL))
},
#' @description fix the automatically detected outliers
#' @param component character vector with names of the components
#' for which the parameters should be changed. If NULL (default) the
#' parameters of all components will be changed
#' @param timespan number of months from the end of the time series
#' where outliers are not fixed
#' @param verbose if TRUE the changed parameters will be reported
fixOutlier = function(component = NULL, timespan = 12, verbose = FALSE) {
  if(!is.null(component)){
    lapply(self$components[component],function(x)x$fixOutlier(timespan = timespan,
                                                              verbose = verbose))
  }else{
    lapply(self$components,function(x)x$fixOutlier(timespan = timespan,
                                                   verbose = verbose))
  }
  return(invisible(NULL))
}
  ),
  active = list(
    #' @field adjusted results from the seasonal adjustment
    adjusted = function() {
      lapply(self$components,function(x)x$adjusted)
    },
    #' @field params of all components
    params = function() {
      lapply(self$components,function(x)x$params)
    },
    #' @field forecasts get forecasts
    forecasts = function() {
      lapply(self$components,function(x)x$forecasts)
    }
  ),
  private = list(
    check_classes = function(components) {
      lapply(components, function(component) {
        stopifnot(is.persephone(component))
      })
    },
    printTable = function() {
      self$iterate(printDiagnostics, asTable = TRUE)
    },
    check_time_instances = function(components) {
      tsps <- lapply(components, function(component) {
        component$tsp
      })
      if (length(unique(tsps)) != 1)
        stop("All components need to have the same time instances")
      tsps[[1]]
    },
    coerce_component_names = function(components) {
      lapply(seq_along(components), function(i) {
        parname <- names(components)[i]
        if (!is.null(parname) && parname != "")
          return(parname)
        else
          stop("all components in 'multipleTimeSeries' must be named")
      })
    },
    super2 = function() { super }
  )

)

#' Define a multiple time series
#'
#' Combine mutliple objects of persephone objects into a new persephone batch object.
#' On the resulting objects, you can perform seasonal adjustment.
#'
#' @param ... ne or more objects which are either of class persephone or can be
#'   coerced to persephone objects with asPersephone. If more than one element
#'   is supplied, the underlying time series must have the same time instances.
#'   All elements supplied in ... must be named.
#' @param list a list of persephone objects as alternative input to `...`. This
#'   argument can also handle mts objects
#' @export
perBatch <- function(..., list = NULL) {
  multipleTimeSeries$new(..., list = list)
}
